<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Time Rhetoric Duel - American Revolution</title>
  <link rel="icon" href="/images/shop/bucket.png">
  <style>
    body {
      font-family: "Arial Rounded MT Bold", Arial, sans-serif;
      background: #f0e6d2;
      color: #333;
      text-align: center;
      padding: 40px;
    }

    h1 {
      color: #E53D00;
      font-size: 2.5em;
    }

    .question-box {
      background: white;
      border: 2px solid #ccc;
      border-radius: 10px;
      padding: 30px;
      margin-top: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }

    .options {
      margin-top: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .option {
      background-color: #2E282A;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 15px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .option:hover {
      background-color: #17BEBB;
    }

    .stats {
      margin-top: 20px;
      font-size: 1.2em;
    }

    .patriot-bar {
      height: 20px;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 10px;
      width: 100%;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .patriot-fill {
      height: 100%;
      width: 50%;
      background-color: #F0C808;
      transition: width 0.3s;
    }

    .timer {
      font-size: 1.5em;
      color: #E53D00;
      margin-top: 10px;
    }
    #hero-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  justify-content: center;
  margin-top: 20px;
}

.hero-card {
  width: 180px;
  background-color: #FFD93D;
  border-radius: 15px;
  padding: 15px;
  box-shadow: 0 5px 10px rgba(0,0,0,0.2);
  text-align: center;
  transition: transform 0.3s;
  cursor: pointer;
}

.hero-card:hover {
  transform: scale(1.05);
}

.hero-card.locked {
  background-color: #ccc;
  filter: grayscale(100%);
  pointer-events: none;
}

.hero-card img {
  width: 100%;
  height: 120px;
  object-fit: contain;
}

.selected {
  border: 4px solid #3B7DDD;
}

#confirm-heroes {
  margin-top: 20px;
  padding: 12px 30px;
  font-size: 1.2em;
  background: #FF4D4D;
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.3s;
}
.victory-banner {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: radial-gradient(circle at center, #FFD700, #FF4D4D);
  color: white;
  font-family: 'Fredoka', sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  z-index: 99999;
  animation: fadeIn 1s ease-out;
}
@keyframes bossEntrance {
  0% { transform: scale(0) rotate(0deg); opacity: 0; }
  50% { transform: scale(1.2) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0deg); opacity: 1; }
}
@keyframes bossAttackAura {
  0% {
    transform: scale(0);
    opacity: 0.8;
  }
  50% {
    transform: scale(1.5);
    opacity: 0.4;
  }
  100% {
    transform: scale(2);
    opacity: 0;
  }
}

.boss-aura {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100px;
  height: 100px;
  background: radial-gradient(circle, #ff5722, #ff9800);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  z-index: 2;
  animation: bossAttackAura 1s ease-out forwards;
  pointer-events: none;
}
@keyframes teamBuffFlash {
  0% { background-color: #ffffff; }
  50% { background-color: #ffeb3b; } /* nice golden flash */
  100% { background-color: #ffffff; }
}

.buff-flash {
  animation: teamBuffFlash 1s ease-out;
}
.glow-attackable {
  animation: glowAttackable 1s infinite alternate;
  box-shadow: 0 0 10px #17BEBB, 0 0 20px #17BEBB;
  cursor: pointer;
}

@keyframes glowAttackable {
  0% { box-shadow: 0 0 5px #17BEBB; }
  100% { box-shadow: 0 0 20px #17BEBB; }
}
.status-icon {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 28px;
  height: 28px;
  z-index: 5;
}

.character-card {
  position: relative; /* Needed for absolute positioning inside */
}

.dead-enemy {
  filter: grayscale(100%) brightness(0.5);
  opacity: 0.6;
  pointer-events: none; /* Prevent clicking dead enemies */
}

.active-character {
  border: 5px solid gold;
  box-shadow: 0 0 30px gold, 0 0 60px orange;
  transform: scale(1.1); /* 🔥 Active character slightly larger */
  animation: pulseActive 1s infinite alternate, bobActive 2s infinite ease-in-out;
  z-index: 10; /* Bring it slightly forward */
}
@keyframes bobActive {
  0% { transform: scale(1.1) translateY(0); }
  50% { transform: scale(1.1) translateY(-5px); }
  100% { transform: scale(1.1) translateY(0); }
}
@keyframes pulseActive {
  0% { box-shadow: 0 0 10px gold; }
  100% { box-shadow: 0 0 20px orange; }
}

@keyframes flipInNew {
    0% {
        transform: translate(-50%, -50%) rotateY(90deg);
        opacity: 0;
    }
    100% {
        transform: translate(-50%, -50%) rotateY(0deg);
        opacity: 1;
    }
}

.boss-arriving {
  animation: bossEntrance 1s ease-out forwards;
}

@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

#confirm-heroes.disabled {
  background: #aaa;
  cursor: not-allowed;
}

    .result {
      font-size: 2em;
      font-weight: bold;
      margin-top: 30px;
    }

    .hidden {
      display: none;
    }
    @keyframes pulseNext {
  0% { transform: translateX(-50%) scale(1); }
  50% { transform: translateX(-50%) scale(1.1); }
  100% { transform: translateX(-50%) scale(1); }
}

#next-button {
  animation: pulseNext 2s infinite;
  z-index: 1000;
}
#victory-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at center, rgba(255, 223, 0, 0.7) 0%, rgba(255, 215, 0, 0.3) 40%, rgba(255, 215, 0, 0) 70%);
  backdrop-filter: blur(4px);
  z-index: 999;
  animation: victoryFade 2s ease forwards;
}

@keyframes victoryFade {
  0% { opacity: 0; }
  100% { opacity: 1; }
}

#battle-arena {
  background-color: #fdf6e3;
  padding: 20px;
  font-family: 'Fredoka', sans-serif;
}
@keyframes elephantStampede {
  0% { transform: translateX(-150%); }
  100% { transform: translateX(150%); }
}

@keyframes shieldWave {
  0% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.5); opacity: 1; }
  100% { transform: scale(1); opacity: 0; }
}

@keyframes mysticGlow {
  0% { opacity: 0; transform: scale(0.5); }
  50% { opacity: 1; transform: scale(1.2); }
  100% { opacity: 0; transform: scale(1); }
}
@keyframes attackMove {
  0% { transform: translateX(0); }
  50% { transform: translateX(20px); }
  100% { transform: translateX(0); }
}

@keyframes hitShake {
  0% { transform: translateX(0); }
  25% { transform: translateX(-10px); }
  50% { transform: translateX(10px); }
  75% { transform: translateX(-10px); }
  100% { transform: translateX(0); }
}

/* These classes apply the animations */
.attack-animation {
  animation: attackMove 0.5s ease;
}
.glowing-ultimate {
  animation: glow 1.5s infinite alternate;
}

@keyframes glow {
  0% {
    box-shadow: 0 0 5px gold, 0 0 10px gold;
  }
  100% {
    box-shadow: 0 0 20px orange, 0 0 30px orange;
  }
}

.hit-animation {
  animation: hitShake 0.5s ease;
}

.elephant {
  font-size: 80px;
  position: absolute;
  top: 30%;
  animation: elephantStampede 2s linear forwards;
  z-index: 9999;
}

.shield {
  width: 150px;
  height: 150px;
  background: radial-gradient(circle, #00f, #3B7DDD);
  border-radius: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  animation: shieldWave 2s ease-out forwards;
  z-index: 9999;
}
#cutscene-next:hover {
  transform: scale(1.05);
  box-shadow: 0 0 30px rgba(255, 223, 0, 0.9), 0 0 60px rgba(255, 140, 0, 0.6);
}

#cutscene-next:active {
  transform: scale(0.95);
}
.glow {
  width: 100px;
  height: 100px;
  background: radial-gradient(circle, #ff69b4, #800080);
  border-radius: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  animation: mysticGlow 2s ease-out forwards;
  z-index: 9999;
}

#enemy-field, #player-team {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;
}

.character-card {
  background: #ffe066;
  border-radius: 15px;
  padding: 10px;
  width: 150px;
  text-align: center;
  box-shadow: 0 4px 10px rgba(0,0,0,0.15);
  position: relative;
}
.character-image {
  width: 100px;
  height: 100px;
  object-fit: contain;
  transition: transform 0.3s;
}
.character-image {
  width: 100px;
  height: 100px;
  object-fit: contain;
  transition: transform 0.3s;
}
#boss-cutscene {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: black;
  color: white;
  font-size: 2em;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 999999;
  
  /* Key parts */
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}

.health-bar {
  height: 10px;
  background: red;
  border-radius: 5px;
  margin-top: 5px;
}

.health-bar-fill {
  height: 100%;
  background: limegreen;
  border-radius: 5px;
  transition: width 0.3s;
}

.battle-button {
  margin-top: 10px;
  padding: 8px 12px;
  font-size: 0.9em;
  background: #3B7DDD;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}

.battle-button:hover {
  background: #2a5fb3;
}
#tooltip {
  position: absolute;
  padding: 10px;
  background: #fff3cd;
  color: #000;
  border: 2px solid #ffca28;
  border-radius: 8px;
  font-size: 0.9em;
  max-width: 200px;
  z-index: 10000;
  pointer-events: none;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  transition: opacity 0.2s;
}
@keyframes shineMove {
  0% { left: -75%; }
  50% { left: 100%; }
  100% { left: 100%; }
}
.hidden {
  display: none;
}

  </style>
</head>
<body>
  <div id="intro-cutscene" style="
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background-color: black;
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain; /* ✨ KEY: contain instead of cover */
  font-family: 'Fredoka', sans-serif;
  font-size: 2em;
  color: white;
  z-index: 99999;
  position: fixed;
  top: 0;
  left: 0;
  overflow: hidden;
  transition: background-image 1.5s ease-in-out;
">
    <div id="cutscene-overlay" style="background: rgba(0,0,0,0.5); width:100%; height:100%; position:absolute; top:0; left:0;"></div>
    <div id="cutscene-text" style="text-align:center; max-width:600px; padding:20px; z-index:1;">Loading...</div>
    <div id="button-container" style="position: relative; display: inline-block;"></div>
    <button id="cutscene-next" style="
  margin-top: 30px;
  padding: 18px 40px;
  font-size: 1.8em;
  font-family: 'Fredoka', sans-serif;
  background: linear-gradient(to bottom, #FFD700, #FFA500);
  color: #2E282A;
  border: 3px solid #E53D00;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.7), 0 0 40px rgba(255, 140, 0, 0.5);
  cursor: pointer;
  display: none;
  z-index: 1;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
">
🎮 Raise the Revolution!
</button>
<!-- ✨ Shine Swipe Element -->
<div id="button-shine" style="
position: absolute;
top: 0;
left: -75%;
width: 50%;
height: 100%;
background: linear-gradient(120deg, transparent, rgba(255,255,255,0.8), transparent);
transform: skewX(-20deg);
pointer-events: none;
opacity: 0.7;
z-index: 2;
"></div>
</div>
  </div>
  
  
    <div id="victory-overlay" style="display:none;">
    </div>    
    <audio id="victory-sound" src="https://cdn.pixabay.com/audio/2022/03/26/audio_bfb4b67960.mp3" preload="auto"></audio>
      
  <h1>Rhetoric Duel: American Revolution 🇺🇸</h1>
  <div id="hero-select-screen" class="hidden">
    <h2>Pick 3 Heroes!</h2>
    <div id="hero-list"></div>
    <button id="confirm-heroes" class="disabled" disabled>Confirm Team</button>
  </div>  
  <div id="battle-arena" class="hidden">
    <div id="enemy-field">
      <!-- Enemy characters go here -->
    </div>
  
    <div id="battle-status-bar">
      <div id="turn-counter" style="font-size: 1.2em; margin-top: 5px;">Turn 1</div>
      <h3 id="turn-indicator">Your Turn</h3>
    </div>
    <div id="tooltip" class="hidden"></div>

    <div id="player-team">
      <!-- Player heroes + action buttons -->
    </div>
  </div>
  <div class="stats">
    Patriot Points: <span id="patriot-score">50</span>/100
    <div class="patriot-bar">
      <div class="patriot-fill" id="patriot-fill"></div>
    </div>
    <div class="timer">⏱️ Time: <span id="time-left">30</span>s</div>
  </div>

  <div class="question-box" id="question-box">
    <div id="question-text">Loading debate...</div>
    <div class="options" id="options"></div>
  </div>

  <div class="result hidden" id="result"></div>
  <button id="next-button" style="display:none; position:fixed; bottom:40px; left:50%; transform:translateX(-50%); padding:15px 30px; font-size:1.5em; background-color:#F0C808; color:#2E282A; border:none; border-radius:10px; cursor:pointer;">
    Next!
  </button>  
  <div id="custom-popup" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; border:3px solid #E53D00; padding:20px 40px; border-radius:15px; font-size:1.2em; z-index:10000; box-shadow:0 4px 10px rgba(0,0,0,0.3);">
    <div id="popup-message">Placeholder</div>
    <button onclick="closeCustomPopup()" style="margin-top:15px; padding:10px 20px; background:#E53D00; color:white; border:none; border-radius:8px; cursor:pointer;">OK</button>
  </div>
  
  <script>
    let targetFriendly = false; // NEW - whether the player should target a friendly hero
    let activeHeroIndex = 0; // Start with first hero
    let awaitingTarget = false;
let pendingHeroIndex = null;
let pendingAttackType = null; // "normal" / "special" / "ultimate"
    const allHeroes = [
  {
    id: 1,
    name: "Hannibal Barca",
    image: "images/heroes/hannibal.png",
    hp: 400,
    maxHp: 400,
    attack: 50,
    attackLines: [
      "Forward! For Carthage!",
      "No mountain can stop me!"
    ],
    hurtLines: [
      "An elephant stepped on me...",
      "They'll pay for that!"
    ],
    special: {
      name: "Elephant Charge",
      type: "damage", // 🔥 NEW
  target: "enemy",
      damage: 100,
      description: "🐘 Deal medium damage and stomp the enemy!"
    },
    ultimate: {
      name: "March Over the Alps",
      type: "damage_team",
  target: "enemy_team",
  damage: 500,
      description: "🐘 Crush enemies for 500 damage after 4 turns!",
      condition: "4_turns_wait",
      used: false
    }
  },
  {
    id: 2,
    name: "Winston Churchill",
    image: "images/heroes/churchill.png",
    hp: 500,
    maxHp: 500,
    attack: 40,
    attackLines: [
      "We shall fight them on the beaches!",
      "Never surrender!"
    ],
    hurtLines: [
      "That's a minor setback!",
      "Cigar... still intact!"
    ],
    special: {
      name: "Battle Cry",
      type: "buff",
  target: "ally_team",
      buff: { attackBoost: 10 },
      description: "🗣️ Boost entire team's attack by 10!"
    },
    ultimate: {
      name: "Iron Will",
      type: "buff_team",
      target: "ally_team",
      duration: 5,
      buff: { defenseBoost: 30 },
      description: "🛡️ Instantly boost defense massively for 5 turns!",
      condition: "usable_anytime",
      used: false
    }
  },
  {
    id: 3,
    name: "Grigori Rasputin",
    image: "images/heroes/rasputin.png",
    hp: 350,
    maxHp: 350,
    attack: 45,
    attackLines: [
      "You can't kill me that easily!",
      "The mystic arts are with me!"
    ],
    hurtLines: [
      "Is that all you've got?",
      "Another stab? Yawn."
    ],
    special: {
      name: "Mystic Heal",
      type: "heal",
  target: "ally",
      heal: 80,
      description: "✨ Heal a teammate for 80 HP!"
    },
    ultimate: {
      name: "Unkillable",
      description: "🔮 Revive once with 50% HP upon death!",
      condition: "on_death",
      used: false
    }
  },
  {
  id: 4,
  name: "Napoleon Bonaparte",
  image: "images/heroes/napoleon.png",
  hp: 420,
  maxHp: 420,
  attack: 55,
  special: {
    name: "Short King Power",
    type: "buff",
    target: "self",
    effect: "double_next_attack",
    description: "Next attack deals double damage."
  },
  ultimate: {
    name: "Grande Armée Stampede",
    type: "damage_team",
    target: "enemy_team",
    damage: 400,
    description: "Summon a giant army — deals 400 team-wide damage."
  },
  attackLines: ["Size doesn't matter!", "Charge!"],
  hurtLines: ["Retreat... tactically!", "I'll be back!"]
},
  {
    id: 5,
    name: "King Louis XVI",
    image: "images/heroes/louisxvi.webp",
    hp: 350,
    maxHp: 350,
    attack: 35,
    special: { name: "Royal Taxation", description: "Drain 20 HP from all enemies.", type: "damage_team", target: "enemy_team", drain: 20 },
    ultimate: { name: "Let Them Eat Cake", description: "Stun all enemies for 1 turn while they feast.", type: "stun_team", target: "enemy_team", duration: 1 },
    attackLines: ["Tax them all!", "Cake solves everything!"],
    hurtLines: ["Uncool, dude!", "Is my head still attached?"]
  },
  {
    id: 6,
    name: "Otto von Bismarck",
    image: "images/heroes/bismarck.png",
    hp: 470,
    maxHp: 470,
    attack: 50,
    special: { name: "Realpolitik", description: "Steal a buff from an enemy.", type: "steal_buff", target: "enemy" },
    ultimate: { name: "Unification Strike", description: "Massive 600 damage combo from all German states.", type: "damage_team", target: "enemy_team", damage: 600 },
    attackLines: ["It’s just pragmatism!", "For Germany!"],
    hurtLines: ["I expected that.", "Tough negotiations."]
  },
  {
    id: 7,
    name: "Kaiser Wilhelm II",
    image: "images/heroes/kaiser.png",
    hp: 440,
    maxHp: 440,
    attack: 45,
    special: { name: "Mustache Twirl", description: "Confuse an enemy (50% miss chance).", type: "debuff", target: "enemy", effect: "confuse", chance: 50 },
    ultimate: { name: "Schlieffen Plan Blitz", description: "Attack 3 random enemies for 300 damage each.", type: "multi_hit", target: "enemy_random", hits: 3, damage_per_hit: 300 },
    attackLines: ["Mustache power!", "Charge!"],
    hurtLines: ["That's rude!", "Unacceptable!"]
  },
  {
    id: 8,
    name: "Tsar Nicholas II",
    image: "images/heroes/tsar.png",
    hp: 400,
    maxHp: 400,
    attack: 40,
    special: { name: "Romanov Resilience", description: "Small heal and defense buff.", type: "heal_buff", target: "self", heal: 50, defenseBoost: 10 },
    ultimate: { name: "Bloody Sunday", description: "Deal massive morale damage (-30% enemy attack for 3 turns).", type: "debuff_team", target: "enemy_team", effect: "lower_attack", percent: 30, duration: 3 },
    attackLines: ["For Mother Russia!", "The people love me... right?"],
    hurtLines: ["Not again...", "Where’s Rasputin when you need him?"]
  },
  {
  id: 9,
  name: "Robespierre",
  image: "images/heroes/robespierre.png",
  hp: 380,
  maxHp: 380,
  attack: 45,
  special: { name: "Committee of Public Safety", description: "Boost allies' attack by 20% for 2 turns.", type: "buff_team", target: "ally_team", attackBoost: 20, duration: 2 },
  ultimate: { name: "Reign of Terror", description: "Inflict bleeding on all enemies (-10% HP per turn for 3 turns).", type: "bleed_team", target: "enemy_team", hpLossPercent: 10, duration: 3 },
  attackLines: ["For the Revolution!", "Let the terror commence!"],
  hurtLines: ["I am incorruptible!", "Not even fear can stop me!"]
},
{
  id: 10,
  name: "King George III",
  image: "images/bosses/kinggeorge.png",
  hp: 450,
  maxHp: 450,
  attack: 40,
  special: { name: "Taxation Without Representation", description: "Weaken enemy defenses for 3 turns.", type: "debuff_team", target: "enemy_team", effect: "lower_defense", duration: 3 },
  ultimate: { name: "Royal Madness", description: "Confuse all enemies (50% miss chance).", type: "debuff_team", target: "enemy_team", effect: "confuse", chance: 50 },
  attackLines: ["Tax them all!", "Long live the King!"],
  hurtLines: ["Uncool, dude!", "Where’s my crown?"]
},
{
  id: 11,
  name: "Joseph Stalin",
  image: "images/heroes/stalin.png",
  hp: 520,
  maxHp: 520,
  attack: 50,
  special: { name: "Purges", description: "Remove buffs from all enemies.", type: "remove_buffs", target: "enemy_team" },
  ultimate: { name: "Five-Year Plan", description: "Massive team buff (+20% attack and defense for 3 turns).", type: "buff_team", target: "ally_team", attackBoost: 20, defenseBoost: 20, duration: 3 },
  attackLines: ["Victory through strength!", "The party leads!"],
  hurtLines: ["Comrade, this is but a scratch.", "Glory to the Motherland!"]
},
{
  id: 12,
  name: "Hitler",
  image: "images/heroes/hitler.png",
  hp: 400,
  maxHp: 400,
  attack: 55,
  special: { name: "Luftwaffe", description: "Deal quick 1.5x damage to a random enemy.", type: "damage", target: "enemy_random", multiplier: 1.5 },
  ultimate: { name: "BLITZKRIEG", description: "Heavy, fast damage to multiple enemies but weakens own defense.", type: "multi_damage", target: "enemy_team", damage: "heavy", side_effect: "lower_own_defense" },
  attackLines: ["Victory will be ours!", "Onward to glory!"],
  hurtLines: ["They'll pay for this!", "No retreat!"]
},
{
  id: 13,
  name: "Fidel Castro",
  image: "images/heroes/castro.png",
  hp: 420,
  maxHp: 420,
  attack: 48,
  special: { name: "They Are All Pigs", description: "Burn enemies (take 5% extra damage per hit for 2 turns).", type: "debuff_team", target: "enemy_team", effect: "burn", damageBoostPercent: 5, duration: 2 },
  ultimate: { name: "Cuban Missile Crisis", description: "Force enemies to skip a turn out of panic.", type: "stun_team", target: "enemy_team", effect: "panic", duration: 1 },
  attackLines: ["Viva la revolución!", "Cuba will prevail!"],
  hurtLines: ["Still fighting!", "Is that all you've got?"]
},
{
  id: 14,
  name: "Woodrow Wilson",
  image: "images/heroes/wilson.png",
  hp: 470,
  maxHp: 470,
  attack: 42,
  special: { name: "Pacifist", description: "Heal allies slightly and reduce enemy attack power.", type: "heal_debuff", target: "both", healAmount: 30, lowerEnemyAttack: 10 },
  ultimate: { name: "League of Nations", description: "Attempt to stun all enemies (50% success rate).", type: "stun_team_chance", target: "enemy_team", chance: 50 },
  attackLines: ["Peace without victory!", "Let's make the world safe!"],
  hurtLines: ["That's not very peaceful!", "Democracy will endure!"]
},
{
  id: 15,
  name: "Franklin D. Roosevelt",
  image: "images/heroes/fdr.png",
  hp: 500,
  maxHp: 500,
  attack: 45,
  special: { name: "New Deal", description: "Heal team and provide shields.", type: "heal_buff_team", target: "ally_team", heal: 50, shield: 30 },
  ultimate: { name: "Arsenal of Democracy", description: "Massively boost team attack and defense for 3 turns.", type: "buff_team", target: "ally_team", attackBoost: 30, defenseBoost: 30, duration: 3 },
  attackLines: ["The only thing to fear is fear itself!", "Victory through unity!"],
  hurtLines: ["This will not deter us!", "The people will endure!"]
}
];

// Load unlocked heroes from localStorage
let unlockedHeroes = JSON.parse(localStorage.getItem('unlockedHeroes')) || [1, 2, 3]; // Default 3 heroes if none yet


const bossTemplates = {
  "King George III": {
    name: "King George III",
    image: "images/bosses/kinggeorge.png",
    hp: 500,
    maxHp: 500,
    isBoss: true,
    attack: 150,
    attackLines: [
    "TAX THEM ALL!",
    "You'll be back!"
    ],
    hurtLines: [
      "How dare you!",
      "Rebellious scum!"
    ],
    special: {
      name: "TAX THEM ALL!",
      description: "200 damage to all heroes",
      turnsCooldown: 3,
      lastUsed: 0
    }
  },
  "King Louis XVI": {
    name: "King Louis XVI",
    hp: 600,
    maxHp: 600,
    isBoss: true,
    attack: 60,
    special: {
      name: "Royal Decree",
      description: "Heals self 100 HP",
      turnsCooldown: 4,
      lastUsed: 0
    }
  }
  // Add more bosses here!
};

    const questions = [
      {
        prompt: "King George III: You owe us taxes for tea! It's only fair.",
        correct: "Then stop throwing tea parties with our money!",
        wrong: ["Long live taxation!", "You're absolutely right, sire.", "Please accept my tea as tribute."]
      },
      {
        prompt: "King George III: How dare you defy the Crown?",
        correct: "How dare you tax our breakfast drinks?",
        wrong: ["We're very sorry!", "The Crown is always right.", "Apologies, Your Majesty."]
      },
      {
        prompt: "King George III: You're nothing without us!",
        correct: "We're everything *despite* you!",
        wrong: ["Yes, we are nothing.", "Please rule us better.", "We'll think about that."]
      },
      {
        prompt: "King George III: We offer protection!",
        correct: "From what? Our own independence?",
        wrong: ["Yes, thank you for protection.", "Keep protecting!", "We'll consider more taxes."]
      },
    ];

    let score = 50;
    let currentIndex = 0;
    let timer = 30;
    let interval = null;

    const questionBox = document.getElementById('question-box');
    const optionsDiv = document.getElementById('options');
    const questionText = document.getElementById('question-text');
    const patriotScore = document.getElementById('patriot-score');
    const patriotFill = document.getElementById('patriot-fill');
    const timeLeft = document.getElementById('time-left');
    const resultBox = document.getElementById('result');
    let soundsEnabled = true; // global variable
    let currentTurnIndex = 0;
let isPlayerTurn = true;
let enemyWave = 1;
let selectedTeam = []; // ← populated from hero selection
let enemies = [];

function startBattle(selected) {
  console.log("Starting Battle!"); // Add debug line
  selectedTeam = selected;
  document.getElementById('hero-select-screen').classList.add('hidden');
  document.getElementById('battle-arena').classList.remove('hidden');

  enemies = generateEnemiesForLevel(1, 1);
  currentTurnIndex = 0;
  enemyWave = 1;
  isPlayerTurn = true;

  renderBattleArena();
  updateTurn();
}


function renderBattleArena() {
  document.getElementById('battle-arena').classList.remove('hidden');

  const playerTeamDiv = document.getElementById('player-team');
  const enemyFieldDiv = document.getElementById('enemy-field');

  playerTeamDiv.innerHTML = '';
  enemyFieldDiv.innerHTML = '';

  selectedTeam.forEach((hero, index) => {
    const card = createCharacterCard(hero, 'player', index);
    playerTeamDiv.appendChild(card);
  });

  enemies.forEach((enemy, index) => {
    const card = createCharacterCard(enemy, 'enemy', index);
    enemyFieldDiv.appendChild(card);
  });
}
function actuallyAttackEnemy(heroIndex, enemyIndex) {
  const hero = selectedTeam[heroIndex];
  const target = enemies[enemyIndex];

  if (!target || target.hp <= 0) {
    showCustomPopup("This enemy has already been defeated!");
    return;
  }

  const randomAttackLine = hero.attackLines[Math.floor(Math.random() * hero.attackLines.length)];
  showFloatingLine(randomAttackLine, "player", heroIndex);

  const heroCard = document.querySelector(`#player-team .character-card:nth-child(${heroIndex + 1}) .character-image`);
  if (heroCard) {
    heroCard.classList.add('attack-animation');
    setTimeout(() => {
      heroCard.classList.remove('attack-animation');
    }, 500);
  }

  const enemyCard = document.querySelector(`#enemy-field .character-card:nth-child(${enemyIndex + 1}) .character-image`);
  if (enemyCard) {
    setTimeout(() => {
      enemyCard.classList.add('hit-animation');
      setTimeout(() => {
        enemyCard.classList.remove('hit-animation');
      }, 500);
    }, 200);
  }

  // Apply damage
  let attackDamage = hero.attack;
if (hero.doubleAttack) {
  attackDamage *= 2;
  hero.doubleAttack = false; // consume the boost
  showBattleAnnouncement(`${hero.name}'s attack is DOUBLED!`);
}
target.hp -= attackDamage;
  updateHealthBars();
  if (target.hurtLines && target.hurtLines.length > 0 && target.hp > 0) {
  const randomHurtLine = target.hurtLines[Math.floor(Math.random() * target.hurtLines.length)];
  showFloatingLine(randomHurtLine, "enemy", enemies.indexOf(target));
}

  if (target.hp <= 0) {
    target.hp = 0;
    updateHealthBars();

    // Check victory
    const aliveEnemies = enemies.filter(e => e.hp > 0);
    if (aliveEnemies.length === 0) {
      if (enemyWave === 1) {
        enemyWave = 2;
        showBattleAnnouncement("👑 Boss Approaching: King George III!", true);

        setTimeout(() => {
          showBossCutscene("King George III", () => {
            enemies = generateEnemiesForLevel(1, 2);
            renderBattleArena();
            isPlayerTurn = true;
            updateTurn();
          });
        }, 1500);
      } else if (enemyWave === 2) {
        handleVictory(1);
      }
      return;
    }
  }

  endTurn();
}

function createCharacterCard(character, type, index) {
  const card = document.createElement('div');
  card.classList.add('character-card');
  card.innerHTML = `
    <img src="${character.image}" alt="${character.name}" class="character-image">
<h4>${character.name}</h4>
<div class="health-bar">
  <div class="health-bar-fill" id="${type}-hp-${index}"></div>
</div>

  `;
  const img = card.querySelector('.character-image');

// Attach hover events for stats tooltip
img.addEventListener('mouseenter', (e) => showCharacterTooltip(e, character));
img.addEventListener('mouseleave', hideTooltip);
if (type === 'enemy') {
  card.addEventListener('click', () => {
    if (!isPlayerTurn) return;
    if (character.hp <= 0) return;
    if (awaitingTarget && !targetFriendly) {
      if (pendingAttackType === "normal") {
        actuallyAttackEnemy(pendingHeroIndex, index);
      } else if (pendingAttackType === "special") {
        actuallyUseSpecialOnEnemy(pendingHeroIndex, index);
      } else if (pendingAttackType === "ultimate") {
        actuallyUseUltimateOnEnemy(pendingHeroIndex, index);
      }

      awaitingTarget = false;
      pendingHeroIndex = null;
      pendingAttackType = null;
      clearHighlightAttackableEnemies();
    }
  });
}

if (type === 'player') {
  const attackBtn = document.createElement('button');
  attackBtn.classList.add('battle-button');
  attackBtn.textContent = "Attack";
  attackBtn.onclick = () => playerAttack(index);

  // Hover for Attack
  attackBtn.addEventListener('mouseenter', (e) => showAttackTooltip(e, character));
  attackBtn.addEventListener('mouseleave', hideTooltip);

  const specialBtn = document.createElement('button');
  specialBtn.classList.add('battle-button');
  specialBtn.textContent = "Special";
  specialBtn.onclick = () => playerSpecial(index);

  // Hover for Special
  specialBtn.addEventListener('mouseenter', (e) => showSpecialTooltip(e, character));
  specialBtn.addEventListener('mouseleave', hideTooltip);

  const ultimateBtn = document.createElement('button');
  ultimateBtn.classList.add('battle-button');
  ultimateBtn.textContent = "Ultimate";
  ultimateBtn.onclick = () => playerUltimate(index);

  // Hover for Ultimate
  ultimateBtn.addEventListener('mouseenter', (e) => showUltimateTooltip(e, character));
  ultimateBtn.addEventListener('mouseleave', hideTooltip);

  card.appendChild(attackBtn);
  card.appendChild(specialBtn);
  card.appendChild(ultimateBtn);

  // 🔥 NOW ADD THIS extra click listener here:
  card.addEventListener('click', () => {
    if (!isPlayerTurn) return;
    if (character.hp <= 0) return;
    if (awaitingTarget && targetFriendly) {
      if (pendingAttackType === "special") {
        actuallyUseSpecialOnAlly(pendingHeroIndex, index);
      }
      
      awaitingTarget = false;
      pendingHeroIndex = null;
      pendingAttackType = null;
      clearHighlightFriendlyHeroes();
    }
  });
}
if (type === 'enemy') {
  const statusImg = document.createElement('img');
  statusImg.classList.add('status-icon');
  statusImg.id = `status-icon-${index}`;
  statusImg.style.display = "none"; // hidden by default
  card.appendChild(statusImg);
}

  return card;
}
function highlightFriendlyHeroes() {
  selectedTeam.forEach((hero, index) => {
    const heroCard = document.querySelector(`#player-team .character-card:nth-child(${index + 1})`);
    if (heroCard && hero.hp > 0) {
      heroCard.classList.add('glow-attackable');
    }
  });
}

function clearHighlightFriendlyHeroes() {
  document.querySelectorAll('#player-team .character-card').forEach(card => {
    card.classList.remove('glow-attackable');
  });
}
function actuallyUseSpecialOnAlly(heroIndex, allyIndex) {
  awaitingTarget = false;
  pendingHeroIndex = null;
  pendingAttackType = null;
  targetFriendly = false;
  clearHighlightFriendlyHeroes();

  const hero = selectedTeam[heroIndex];
  const ally = selectedTeam[allyIndex];

  if (!ally || ally.hp <= 0) {
    showCustomPopup("This ally is already defeated!");
    return;
  }

  const special = hero.special;

  if (special.type === "heal") {
    ally.hp = Math.min(ally.maxHp, ally.hp + special.heal);
    showBattleAnnouncement(`${hero.name} heals ${ally.name} for ${special.heal} HP!`);
  }
  else if (special.type === "buff") {
    if (special.target === "ally_team") {
      selectedTeam.forEach(h => {
        h.attack += special.buff.attackBoost || 0;
        h.defenseBoost = (h.defenseBoost || 0) + (special.buff.defenseBoost || 0);
      });
      playTeamBuffFlash();
      showBattleAnnouncement(`${hero.name} buffs the entire team!`);
    } else {
      ally.attack += special.buff.attackBoost || 0;
      ally.defenseBoost = (ally.defenseBoost || 0) + (special.buff.defenseBoost || 0);
      showBattleAnnouncement(`${hero.name} buffs ${ally.name}!`);
    }
  }
  else if (special.type === "heal_buff") {
    ally.hp = Math.min(ally.maxHp, ally.hp + special.heal);
    ally.defenseBoost = (ally.defenseBoost || 0) + special.defenseBoost;
    showBattleAnnouncement(`${hero.name} heals and buffs ${ally.name}!`);
  }
  else if (special.type === "heal_buff_team") {
    selectedTeam.forEach(h => {
      h.hp = Math.min(h.maxHp, h.hp + special.heal);
      h.shield = (h.shield || 0) + special.shield;
    });
    playTeamBuffFlash();
    showBattleAnnouncement(`${hero.name} heals and shields the entire team!`);
  }
  else if (special.type === "heal_debuff") {
    selectedTeam.forEach(h => {
      h.hp = Math.min(h.maxHp, h.hp + special.healAmount);
    });
    enemies.forEach(e => {
      e.attack -= special.lowerEnemyAttack;
    });
    showBattleAnnouncement(`${hero.name} heals allies and weakens enemies!`);
  }

  updateHealthBars();
  endTurn();
}



function actuallyUseSpecialOnEnemy(heroIndex, enemyIndex) {
  const hero = selectedTeam[heroIndex];
  const target = enemies[enemyIndex];

  if (!target || target.hp <= 0) {
    showCustomPopup("This enemy is already defeated!");
    return;
  }

  const special = hero.special;

  if (special.type === "damage") {
    target.hp -= special.damage;
    showBattleAnnouncement(`${hero.name} uses ${special.name} and deals ${special.damage} damage!`);
  } 
  else if (special.type === "debuff") {
    // Example for debuffs like confuse
    showBattleAnnouncement(`${hero.name} uses ${special.name}! ${target.name} is affected.`);
  }
  else if (special.type === "steal_buff") {
    if (target.buff) {
      hero.buff = target.buff;
      delete target.buff;
      showBattleAnnouncement(`${hero.name} steals a buff from ${target.name}!`);
    } else {
      showBattleAnnouncement(`${hero.name} tries to steal but ${target.name} has no buffs!`);
    }
  }

  updateHealthBars();
  if (target.hp <= 0) {
    target.hp = 0;
    updateHealthBars();

    // Check victory
    const aliveEnemies = enemies.filter(e => e.hp > 0);
    if (aliveEnemies.length === 0) {
      if (enemyWave === 1) {
        enemyWave = 2;
        showBattleAnnouncement("👑 Boss Approaching: King George III!", true);

        setTimeout(() => {
          showBossCutscene("King George III", () => {
            enemies = generateEnemiesForLevel(1, 2);
            renderBattleArena();
            isPlayerTurn = true;
            updateTurn();
          });
        }, 1500);
      } else if (enemyWave === 2) {
        handleVictory(1);
      }
      return;
    }
  }
  endTurn();
}

function actuallyUseUltimateOnEnemy(heroIndex, enemyIndex) {
  const hero = selectedTeam[heroIndex];

  if (hero.ultimate.used) {
    showCustomPopup("Ultimate already used!");
    return;
  }

  const target = enemies[enemyIndex];
  const ultimate = hero.ultimate;

  if (!target || target.hp <= 0) {
    showCustomPopup("This enemy is already defeated!");
    return;
  }

  if (ultimate.type === "damage_team") {
    enemies.forEach(e => {
      e.hp -= ultimate.damage;
    });
    showBattleAnnouncement(`${hero.name} unleashes ${ultimate.name} on all enemies!`);
  }
  else if (ultimate.type === "damage") {
    target.hp -= ultimate.damage;
    showBattleAnnouncement(`${hero.name} uses ${ultimate.name} and deals ${ultimate.damage} damage to ${target.name}!`);
  }
  else if (ultimate.type === "buff_team") {
    selectedTeam.forEach(h => {
      h.attack += ultimate.attackBoost;
      h.defenseBoost = (h.defenseBoost || 0) + ultimate.defenseBoost;
    });
    playTeamBuffFlash();
    showBattleAnnouncement(`${hero.name} empowers the team with ${ultimate.attackBoost} attack and ${ultimate.defenseBoost} defense!`);
  }
  else if (ultimate.type === "debuff_team") {
    enemies.forEach(e => {
      e.attack -= (ultimate.percent || 0);
      e.status = ultimate.effect;
    });
    showBattleAnnouncement(`${hero.name} debuffs the entire enemy team!`);
  }
  else if (ultimate.type === "stun_team") {
    enemies.forEach(e => {
      e.status = "stunned";
    });
    showBattleAnnouncement(`${hero.name} stuns the enemy team!`);
  }
  else if (ultimate.type === "bleed_team") {
    enemies.forEach(e => {
      e.status = "bleeding";
    });
    showBattleAnnouncement(`${hero.name} inflicts bleeding on all enemies!`);
  }
  else if (ultimate.type === "multi_hit") {
    for (let i = 0; i < ultimate.hits; i++) {
      const aliveEnemies = enemies.filter(e => e.hp > 0);
      if (aliveEnemies.length === 0) break;
      const randomEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
      randomEnemy.hp -= ultimate.damage_per_hit;
    }
    showBattleAnnouncement(`${hero.name} strikes multiple enemies with ${ultimate.name}!`);
  }
  else if (ultimate.type === "multi_damage") {
    enemies.forEach(e => {
      e.hp -= 100; // heavy damage to all (you can customize)
    });
    const attacker = selectedTeam[heroIndex];
    attacker.defenseBoost = (attacker.defenseBoost || 0) - 20; // lose some defense
    showBattleAnnouncement(`${hero.name} blitzes all enemies but sacrifices defense!`);
  }
  else if (ultimate.type === "stun_team_chance") {
    enemies.forEach(e => {
      if (Math.random() * 100 < ultimate.chance) {
        e.status = "stunned";
      }
    });
    showBattleAnnouncement(`${hero.name} tries to stun the enemy team!`);
  }
  else if (ultimate.type === "buff_team") {
  selectedTeam.forEach(h => {
    h.attack += ultimate.attackBoost || 0;
    h.defenseBoost = (h.defenseBoost || 0) + (ultimate.defenseBoost || 0);
  });
  playTeamBuffFlash();
  showBattleAnnouncement(`${hero.name} empowers the team with ${ultimate.attackBoost} attack and ${ultimate.defenseBoost} defense!`);
}
  if (ultimate.target === "self") {
    showBattleAnnouncement(`🛡️ ${hero.name} powers up themselves!`, true);
  } else if (ultimate.target === "ally_team") {
    showBattleAnnouncement(`🛡️ ${hero.name} empowers the whole team!`, true);
  } else if (ultimate.target === "enemy_team") {
    showBattleAnnouncement(`⚔️ ${hero.name} unleashes devastation on ALL enemies!`, true);
  } else if (ultimate.target.includes("enemy_random")) {
    showBattleAnnouncement(`🎯 ${hero.name} strikes random enemies!`, true);
  } else {
    showBattleAnnouncement(`⚔️ ${hero.name} unleashes a mighty strike on ${enemies[targetIndex].name}!`, true);
  }

  hero.ultimate.used = true;
  updateHealthBars();
  if (target.hp <= 0) {
    target.hp = 0;
    updateHealthBars();

    // Check victory
    const aliveEnemies = enemies.filter(e => e.hp > 0);
    if (aliveEnemies.length === 0) {
      if (enemyWave === 1) {
        enemyWave = 2;
        showBattleAnnouncement("👑 Boss Approaching: King George III!", true);

        setTimeout(() => {
          showBossCutscene("King George III", () => {
            enemies = generateEnemiesForLevel(1, 2);
            renderBattleArena();
            isPlayerTurn = true;
            updateTurn();
          });
        }, 1500);
      } else if (enemyWave === 2) {
        handleVictory(1);
      }
      return;
    }
  }
  endTurn();
}


function playerAttackEnemy(enemyIndex) {
  const hero = selectedTeam[activeHeroIndex];
  const target = enemies[enemyIndex];

  if (!target || target.hp <= 0) {
    showCustomPopup("This enemy has already been defeated!");
    return;
  }

  const randomAttackLine = hero.attackLines[Math.floor(Math.random() * hero.attackLines.length)];
  showFloatingLine(randomAttackLine, "player", activeHeroIndex);

  const heroCard = document.querySelector(`#player-team .character-card:nth-child(${activeHeroIndex + 1}) .character-image`);
  if (heroCard) {
    heroCard.classList.add('attack-animation');
    setTimeout(() => {
      heroCard.classList.remove('attack-animation');
    }, 500);
  }

  const enemyCard = document.querySelector(`#enemy-field .character-card:nth-child(${enemyIndex + 1}) .character-image`);
  if (enemyCard) {
    setTimeout(() => {
      enemyCard.classList.add('hit-animation');
      setTimeout(() => {
        enemyCard.classList.remove('hit-animation');
      }, 500);
    }, 200);
  }

  // Apply damage
  target.hp -= hero.attack;
  updateHealthBars();
  if (target.hurtLines && target.hurtLines.length > 0 && target.hp > 0) {
  const randomHurtLine = target.hurtLines[Math.floor(Math.random() * target.hurtLines.length)];
  showFloatingLine(randomHurtLine, "enemy", enemies.indexOf(target));
}

  if (target.hp <= 0) {
    target.hp = 0; // Make sure health doesn't go negative
    updateHealthBars(); // Update visuals again to gray out dead enemy

    // Check if all enemies defeated
    const aliveEnemies = enemies.filter(e => e.hp > 0);
    if (aliveEnemies.length === 0) {
      if (enemyWave === 1) {
        enemyWave = 2;
        showBattleAnnouncement("👑 Boss Approaching: King George III!", true);

        setTimeout(() => {
          showBossCutscene("King George III", () => {
            enemies = generateEnemiesForLevel(1, 2);
            renderBattleArena();
            isPlayerTurn = true;
            updateTurn();
          });
        }, 1500);
      } else if (enemyWave === 2) {
        handleVictory(1);
      }
      return; // Important: Stop further processing
    }
  }

  endTurn();
}
function playTeamBuffFlash() {
  const playerCards = document.querySelectorAll('#player-team .character-card');
  playerCards.forEach(card => {
    card.classList.add('buff-flash');
    setTimeout(() => {
      card.classList.remove('buff-flash');
    }, 1000); // match animation length
  });
}
function playBossAttackAura(enemyIndex) {
  const enemyCard = document.querySelector(`#enemy-field .character-card:nth-child(${enemyIndex + 1})`);
  if (!enemyCard) return;

  const aura = document.createElement('div');
  aura.classList.add('boss-aura');
  enemyCard.appendChild(aura);

  setTimeout(() => {
    aura.remove();
  }, 1000); // Match the animation length
}

function showCharacterTooltip(event, character) {
  const tooltip = document.getElementById('tooltip');
  
  tooltip.innerHTML = `
    <strong>${character.name}</strong><br>
    ❤️ HP: ${Math.max(character.hp, 0)} / ${character.maxHp}<br>
    🛡️ Defense Boost: ${character.defenseBoost ? character.defenseBoost : 0}
  `;

  tooltip.style.top = (event.clientY + 10) + 'px';
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.classList.remove('hidden');
}

function showAttackTooltip(event, character) {
  const tooltip = document.getElementById('tooltip');
  tooltip.innerHTML = `
    <strong>Normal Attack</strong><br>
    Deals ${character.attack} base damage.
  `;
  tooltip.style.top = (event.clientY + 10) + 'px';
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.classList.remove('hidden');
}

function showSpecialTooltip(event, character) {
  const tooltip = document.getElementById('tooltip');
  tooltip.innerHTML = `
    <strong>Special Move: ${character.special.name}</strong><br>
    ${character.special.description}
  `;
  tooltip.style.top = (event.clientY + 10) + 'px';
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.classList.remove('hidden');
}

function showUltimateTooltip(event, character) {
  const tooltip = document.getElementById('tooltip');

  let conditionText = "";
  if (character.ultimate.condition === "4_turns_wait") {
    const remaining = Math.max(4 - currentTurnIndex, 0);
    conditionText = remaining > 0 ? `Available after ${remaining} more turns.` : "Ready now!";
  } else if (character.ultimate.condition === "low_hp") {
    conditionText = (character.hp / character.maxHp <= 0.5) ? "Ready now!" : "Useable under 50% HP.";
  } else if (character.ultimate.condition === "on_death") {
    conditionText = "Automatically triggers upon death.";
  } else {
    conditionText = "Can be used anytime.";
  }

  tooltip.innerHTML = `
    <strong>${character.ultimate.name}</strong><br>
    ${character.ultimate.description}<br>
    <em>${conditionText}</em>
  `;

  tooltip.style.top = (event.clientY + 10) + 'px';
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.classList.remove('hidden');
}

function hideTooltip() {
  const tooltip = document.getElementById('tooltip');
  tooltip.classList.add('hidden');
}
document.addEventListener('mousemove', function(e) {
  const tooltip = document.getElementById('tooltip');
  if (!tooltip.classList.contains('hidden')) {
    tooltip.style.top = (e.clientY + 10) + 'px';
    tooltip.style.left = (e.clientX + 10) + 'px';
  }
});

function playerSpecial(heroIndex) {
  if (heroIndex !== activeHeroIndex) {
    showCustomPopup("⏳ It's not your turn yet! Wait for your active hero.");
    return;
  }

  const hero = selectedTeam[heroIndex];
  const special = hero.special;

  if (special.target === "self" || special.target === "ally_team") {
    // Auto-cast immediately
    actuallyUseSpecialOnAlly(heroIndex, heroIndex);
    return;
  }

  awaitingTarget = true;
  pendingHeroIndex = heroIndex;
  pendingAttackType = "special";

  if (special.target === "ally") {
    targetFriendly = true;
    highlightFriendlyHeroes();
    showBattleAnnouncement("✨ Choose a teammate to heal or buff!", true);
  } else {
    targetFriendly = false;
    highlightAttackableEnemies();
    showBattleAnnouncement("✨ Choose an enemy for Special Attack!", true);
  }
}

function playerUltimate(heroIndex) {
  if (heroIndex !== activeHeroIndex) {
    showCustomPopup("⏳ It's not your turn yet! Wait for your active hero.");
    return;
  }

  const hero = selectedTeam[heroIndex];
  const ultimate = hero.ultimate;
  if (ultimate.used) {
    showCustomPopup("Ultimate already used!");
    return;
  }

  // 🔥 NEW LOGIC
  if (!ultimate.target || ultimate.target.includes('team') || ultimate.target.includes('self')) {
    if (ultimate.type.includes('buff')) {
      // For buff-type team ultimates (e.g., Churchill)
      actuallyUseUltimateOnSelfOrTeam(heroIndex);
    } else {
      // For damage-type team ultimates
      actuallyUseUltimateOnEnemies(heroIndex);
    }
    return;
  }

  awaitingTarget = true;
  pendingHeroIndex = heroIndex;
  pendingAttackType = "ultimate";

  if (ultimate.target.includes("ally")) {
    targetFriendly = true;
    highlightFriendlyHeroes();
    showBattleAnnouncement("✨ Choose a teammate for Ultimate!", true);
  } else {
    targetFriendly = false;
    highlightAttackableEnemies();
    showBattleAnnouncement("💥 Choose an enemy for Ultimate!", true);
  }
}

function actuallyUseUltimateOnSelfOrTeam(heroIndex) {
  const hero = selectedTeam[heroIndex];
  const ultimate = hero.ultimate;

  if (ultimate.type.includes("buff")) {
    selectedTeam.forEach(h => {
      h.attack += ultimate.attackBoost || 0;
      h.defenseBoost = (h.defenseBoost || 0) + (ultimate.defenseBoost || 0);
    });
    playTeamBuffFlash();
    showBattleAnnouncement(`${hero.name} boosts the team's attack and defense!`);
  }

  hero.ultimate.used = true;
  updateHealthBars();
  endTurn();
}
function actuallyUseUltimateOnEnemies(heroIndex) {
  const hero = selectedTeam[heroIndex];
  const ultimate = hero.ultimate;

  if (ultimate.type.includes("damage")) {
    enemies.forEach(e => {
      e.hp -= ultimate.damage;
    });
    showBattleAnnouncement(`${hero.name} unleashes destruction on all enemies!`);
  }

  hero.ultimate.used = true;
  updateHealthBars();
  endTurn();
}

function highlightAttackableEnemies() {
  enemies.forEach((enemy, index) => {
    const enemyCard = document.querySelector(`#enemy-field .character-card:nth-child(${index + 1})`);
    if (enemyCard && enemy.hp > 0) {
      enemyCard.classList.add('glow-attackable');
    }
  });
}

function clearHighlightAttackableEnemies() {
  document.querySelectorAll('#enemy-field .character-card').forEach(card => {
    card.classList.remove('glow-attackable');
  });
}


function showFloatingLine(text, characterType, characterIndex) {
  const card = document.querySelector(`#${characterType}-team .character-card:nth-child(${characterIndex + 1})`);

  if (!card) return;

  const line = document.createElement('div');
  line.textContent = text;
  line.style.position = 'absolute';
  line.style.top = '-30px'; // slightly above the card
  line.style.left = '50%';
  line.style.transform = 'translateX(-50%)';
  line.style.background = 'white';
  line.style.color = 'black';
  line.style.padding = '5px 10px';
  line.style.borderRadius = '10px';
  line.style.fontSize = '0.9em';
  line.style.zIndex = 5;
  line.style.animation = 'floatUp 2s forwards';
  line.classList.add('floating-line');

  card.style.position = 'relative'; // make sure the card is the parent reference
  card.appendChild(line);

  setTimeout(() => {
    line.remove();
  }, 3000);
}

// Add floating text animation
const styleSheet = document.createElement("style");
styleSheet.innerHTML = `
@keyframes floatUp {
  0% { transform: translate(-50%, 0); opacity: 1; }
  100% { transform: translate(-50%, -150px); opacity: 0; }
}`;
document.head.appendChild(styleSheet);
const damageStyle = document.createElement('style');
damageStyle.innerHTML = `
.damage-number {
  position: absolute;
  color: red;
  font-weight: bold;
  font-size: 1.5em;
  animation: floatUp 1.5s forwards;
  z-index: 100;
  text-shadow: 1px 1px 2px black;
}`;
document.head.appendChild(damageStyle);

function canUseUltimate(hero) {
  if (hero.ultimate.used) return false;

  if (hero.ultimate.condition === "4_turns_wait") {
    return currentTurnIndex >= 4;
  }
  if (hero.ultimate.condition === "low_hp") {
    return (hero.hp / hero.maxHp) <= 0.5;
  }
  return false;
}


function updateHealthBar(type, index, current, max) {
  const fill = document.getElementById(`${type}-hp-${index}`);
  const percent = Math.max((current / max) * 100, 0);
  fill.style.width = percent + '%';
}
function updateHealthBars() {
  selectedTeam.forEach((hero, i) => {
    updateHealthBar('player', i, hero.hp, hero.maxHp);
  });

  enemies.forEach((enemy, i) => {
    updateHealthBar('enemy', i, enemy.hp, enemy.maxHp);

    const enemyCard = document.querySelector(`#enemy-field .character-card:nth-child(${i + 1})`);
    const statusIcon = document.getElementById(`status-icon-${i}`);

    if (enemyCard && statusIcon) {
      if (enemy.hp <= 0) {
        enemyCard.classList.add('dead-enemy');
        statusIcon.style.display = "none"; // dead enemies have no status icons
      } else {
        enemyCard.classList.remove('dead-enemy');

        // Show correct status icon
        if (enemy.status === "bleeding") {
          statusIcon.src = "images/status/bleed.png"; // 🩸 Bleeding icon
          statusIcon.style.display = "block";
        }
        else if (enemy.status === "stunned") {
          statusIcon.src = "images/status/stun.png"; // 🌟 Stunned icon
          statusIcon.style.display = "block";
        }
        else if (enemy.status === "confuse") {
          statusIcon.src = "images/status/confuse.png"; // 🔄 Confused icon
          statusIcon.style.display = "block";
        }
        else {
          statusIcon.style.display = "none"; // No status
        }
      }
    }
  });
}

function playerAttack(heroIndex) {
  if (heroIndex !== activeHeroIndex) {
    showCustomPopup("⏳ It's not your turn yet! Wait for your active hero.");
    return;
  }

  clearHighlightFriendlyHeroes();
  clearHighlightAttackableEnemies();

  awaitingTarget = true;
  targetFriendly = false;
  highlightAttackableEnemies();
  pendingHeroIndex = heroIndex;
  pendingAttackType = "normal";

  showBattleAnnouncement("🛡️ Choose an enemy to attack!", true);
}

function handleVictory(level) {
  // 1. Create colorful victory banner (full screen)
  document.getElementById('victory-overlay').style.display = 'none';
  const overlay = document.createElement('div');
  overlay.classList.add('victory-banner');
  overlay.id = 'dynamic-victory-banner'; // ← give it an id so we can remove it later
  overlay.innerHTML = `
    <h1>🏆 You Won!</h1>
    <p>Looting a reward from history...</p>
  `;
  document.body.appendChild(overlay);

  // 2. Save highest level
  const highestLevel = parseInt(localStorage.getItem('highestLevelWon') || "1");
  if (level > highestLevel) {
    localStorage.setItem('highestLevelWon', level);
  }

  // 3. Reward player
  const rewards = JSON.parse(localStorage.getItem('playerRewards')) || [];
  const newReward = `Historical Artifact Lv.${level}`;
  rewards.push(newReward);
  localStorage.setItem('playerRewards', JSON.stringify(rewards));

  // 4. Unlock next hero
  let unlocked = JSON.parse(localStorage.getItem('unlockedHeroes')) || [1, 2, 3];
  const allHeroIds = allHeroes.map(h => h.id).sort((a, b) => a - b);
  const nextHero = allHeroIds.find(id => !unlocked.includes(id));

  if (nextHero) {
    unlocked.push(nextHero);
    localStorage.setItem('unlockedHeroes', JSON.stringify(unlocked));
  }

  // 5. After 3.5 seconds, fade out victory banner, show New Hero card
  setTimeout(() => {
    const banner = document.getElementById('dynamic-victory-banner');
    if (banner) {
      banner.style.transition = 'opacity 1s ease';
      banner.style.opacity = '0';
      setTimeout(() => {
        banner.remove(); // Remove after faded out
      }, 1000);
    }
    // 🛠️ NEW - After unlock card disappears, hide battle arena
document.getElementById('battle-arena').classList.add('hidden');

// 🛠️ NEW - Create a clean victory message
// After hiding old overlays, create final victory screen
const finalVictoryScreen = document.createElement('div');
finalVictoryScreen.id = 'final-victory-screen';
finalVictoryScreen.style = `
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(to bottom right, #FFD700, #FF4D4D);
  color: white;
  font-family: 'Fredoka', sans-serif;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-size: 2.5em;
  z-index: 9999;
  animation: fadeIn 1.5s ease forwards;
  pointer-events: none; /* 👈 ADD THIS */
`;
finalVictoryScreen.innerHTML = `
  <h1>🏆 Victory!</h1>
  <p style="margin-top:20px; font-size:1.2em;">You rewrote history!</p>
`;
document.body.appendChild(finalVictoryScreen);

// Then after the victory pops up, finally show the Next button
setTimeout(() => {
  const nextButton = document.getElementById('next-button');
  nextButton.style.display = 'block';

// ✨ Trigger shine swipe when button appears
const buttonShine = document.getElementById('button-shine');
buttonShine.style.animation = 'shineMove 2s ease-out forwards';

  nextButton.style.zIndex = '10001'; // 👈 make sure Next button is ABOVE the final screen
  if (nextHero) {
      showNewHeroPopup(nextHero); // 🎉 show collectible unlock
    }
    nextButton.onclick = () => {
  const victoryScreen = document.getElementById('final-victory-screen');
  if (victoryScreen) {
    victoryScreen.style.transition = 'opacity 0.5s ease';
    victoryScreen.style.opacity = '0';
    setTimeout(() => {
      window.location.href = `index.html?levelWon=${level}`;
    }, 500);
  } else {
    window.location.href = `index.html?levelWon=${level}`;
  }
};
}, 2500);
  }, 3500);
}


function endTurn() {
  isPlayerTurn = !isPlayerTurn;

  if (isPlayerTurn) {
    currentTurnIndex++; 
    updateTurn();
  } else {
    // NEW ✨ Add a longer delay after player move finishes
    setTimeout(() => {
      enemyTurn();
    }, 1500); // 1.5 seconds feels much smoother
  }
}

function showNewHeroPopup(heroId) {
  const hero = allHeroes.find(h => h.id === heroId);
  if (!hero) return;

  const banner = document.createElement('div');
  banner.id = 'new-hero-banner';
  banner.style = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotateY(90deg);
    background: #fff8dc;
    color: #2E282A;
    border: 4px solid gold;
    border-radius: 20px;
    padding: 30px;
    width: 300px;
    text-align: center;
    font-size: 1.1em;
    font-weight: bold;
    z-index: 10000;
    box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    animation: flipInNew 0.6s ease forwards;
  `;

  banner.innerHTML = `
    <h2 style="color: goldenrod;">🎉 New Hero Unlocked!</h2>
    <img src="${hero.image}" alt="${hero.name}" style="width:100px;height:120px;margin-top:10px;border:3px solid goldenrod;border-radius:10px;">
    <h3 style="margin-top:10px;">${hero.name}</h3>
    <p style="margin-top:5px;font-size:0.9em;">✨ Special: ${hero.special?.name || 'Unknown'}</p>
  `;

  document.body.appendChild(banner);

  setTimeout(() => {
    banner.remove();
  }, 2500);
}


function updateTurn() {
  const turnIndicator = document.getElementById('turn-indicator');
  const turnCounter = document.getElementById('turn-counter');

  turnCounter.textContent = `Turn ${currentTurnIndex + 1}`;

  if (isPlayerTurn) {
    activeHeroIndex = currentTurnIndex % selectedTeam.length; // Cycle through heroes
    // Clear previous active highlights
document.querySelectorAll('.character-card').forEach(card => {
  card.classList.remove('active-character');
});

// Highlight the active hero
const playerCards = document.querySelectorAll('#player-team .character-card');
if (playerCards[activeHeroIndex]) {
  playerCards[activeHeroIndex].classList.add('active-character');
}
    turnIndicator.textContent = `🎯 Your Turn - ${selectedTeam[activeHeroIndex].name}!`;
  } else {
    turnIndicator.textContent = "🎯 Enemy Turn!";
  }
  

  if (isPlayerTurn) {
  const ultimateButtons = document.querySelectorAll('.battle-button');

  selectedTeam.forEach((hero, index) => {
    const ultimateBtn = document.querySelector(`#player-team .character-card:nth-child(${index + 1}) .battle-button:nth-child(3)`);

    if (!ultimateBtn) return;

    if (hero.name === "Hannibal Barca") {
      if (currentTurnIndex >= 4 && !hero.ultimate.used) {
        ultimateBtn.classList.add('glowing-ultimate');
      } else {
        ultimateBtn.classList.remove('glowing-ultimate');
      }
    }

    if (hero.name === "Winston Churchill") {
      if (!hero.ultimate.used) {
        ultimateBtn.classList.add('glowing-ultimate');
      } else {
        ultimateBtn.classList.remove('glowing-ultimate');
      }
    }

    if (hero.name === "Grigori Rasputin") {
      // His Ultimate auto-triggers, no manual activation
      ultimateBtn.classList.remove('glowing-ultimate');
    }
  });
} else {
    turnIndicator.textContent = "🎯 Enemy Turn!";
  }
}

function enemyTurn() {
  const aliveHeroes = selectedTeam.filter(h => h.hp > 0);
  const aliveEnemies = enemies.filter(e => e.hp > 0);

  if (aliveEnemies.length === 0) {
    handleVictory(1);
    return;
  }

  const attacker = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
  const attackerIndex = enemies.findIndex(e => e.name === attacker.name && e.hp === attacker.hp && e.image === attacker.image);
  
  document.querySelectorAll('.character-card').forEach(card => {
    card.classList.remove('active-character');
  });
  
  // Highlight attacking enemy
  const enemyCards = document.querySelectorAll('#enemy-field .character-card');
  if (enemyCards[attackerIndex]) {
    enemyCards[attackerIndex].classList.add('active-character');
  }
  const randomAttackLine = attacker.attackLines[Math.floor(Math.random() * attacker.attackLines.length)];
  showFloatingLine(randomAttackLine, "enemy", attackedIndex);

if (attacker.isBoss) {
  playBossAttackAura(attackerIndex);
} else {
  showBattleAnnouncement(`⚔️ ${attacker.name} is preparing to attack!`, true);
}

setTimeout(() => {}, 1500);
setTimeout(() => {
    // Handle bleeding
    if (attacker.status === "bleeding") {
      attacker.hp -= Math.floor(attacker.maxHp * 0.05); // 5% bleed damage
      showBattleAnnouncement(`💉 ${attacker.name} suffers from bleeding!`);
      updateHealthBars();

      if (attacker.hp <= 0) {
        attacker.hp = 0;
        updateHealthBars();
        setTimeout(endTurn, 800);
        return;
      }
    }

    // Handle stunned
    if (attacker.status === "stunned") {
      showBattleAnnouncement(`💫 ${attacker.name} is stunned and cannot act!`);
      updateHealthBars();
      setTimeout(endTurn, 800);
      return;
    }

    // Select target and perform attack
    setTimeout(() => {
      // Choose target
      let targetHero = aliveHeroes[Math.floor(Math.random() * aliveHeroes.length)];
      let targetIndex = selectedTeam.indexOf(targetHero);
      
      // Handle confusion
      if (attacker.status === "confuse" && Math.random() < 0.5) {
        targetHero = attacker;
        targetIndex = attackerIndex;
        showBattleAnnouncement(`🔄 ${attacker.name} is confused and attacks themselves!`);
      }
      
      showBattleAnnouncement(`${attacker.name} attacks ${targetHero.name}!`);
      
      // Play hit animation
      const heroCard = (targetHero === attacker) 
        ? document.querySelector(`#enemy-field .character-card:nth-child(${attackerIndex + 1}) .character-image`)
        : document.querySelector(`#player-team .character-card:nth-child(${targetIndex + 1}) .character-image`);

      if (heroCard) {
        heroCard.classList.add('hit-animation');
        setTimeout(() => {
          heroCard.classList.remove('hit-animation');
        }, 500);
      }

      // THIS IS THE KEY FIX - Calculate and apply damage correctly
      let incomingDamage = attacker.attack;
      if (targetHero.defenseBoost) {
        incomingDamage = Math.max(10, incomingDamage - targetHero.defenseBoost);
      }
      targetHero.hp -= incomingDamage;
      
      // Show damage amount as floating text
      const damageText = document.createElement('div');
      damageText.textContent = `-${incomingDamage}`;
      damageText.classList.add('damage-number');
      
      const targetCard = (targetHero === attacker) 
        ? document.querySelector(`#enemy-field .character-card:nth-child(${attackerIndex + 1})`)
        : document.querySelector(`#player-team .character-card:nth-child(${targetIndex + 1})`);
        
      if (targetCard) {
        targetCard.appendChild(damageText);
        setTimeout(() => {
          damageText.remove();
        }, 1000);
      }
      
      // Show hurt line if applicable
      if (targetHero.hurtLines && targetHero !== attacker && targetHero.hp > 0) {
        setTimeout(() => {
          const randomHurtLine = targetHero.hurtLines[Math.floor(Math.random() * targetHero.hurtLines.length)];
          showFloatingLine(randomHurtLine, "player", targetIndex);
        }, 400);
      }
      
      updateHealthBars();
      
      // Check for special abilities (like Rasputin's revival)
      if (targetHero.hp <= 0 && targetHero.name === "Grigori Rasputin" && !targetHero.ultimate.used) {
        playMysticGlow();
        targetHero.hp = targetHero.maxHp / 2;
        targetHero.ultimate.used = true;
        showBattleAnnouncement("🔮 Rasputin resurrects!");
        updateHealthBars();
      }
      
      // Check for defeat
      if (targetHero.hp <= 0) {
        targetHero.hp = 0;
        updateHealthBars();
        
        // Check if all heroes are defeated
        const remainingHeroes = selectedTeam.filter(h => h.hp > 0);
        if (remainingHeroes.length === 0) {
          // No need to immediately call showDefeatScreen - let the UI update first
          setTimeout(() => {
            showDefeatScreen();
          }, 500);
          return;
        }
      }
      // End turn after a short delay
      setTimeout(endTurn, 800);
    }, 800);
    
  }, 1000);
}

function highlightActiveCharacter(index, type) {
  // Clear all active highlights
  document.querySelectorAll('.character-card').forEach(card => {
    card.classList.remove('active-character');
  });
  
  // Add highlight to active character
  const selector = type === "enemy" ? 
    `#enemy-field .character-card:nth-child(${index + 1})` : 
    `#player-team .character-card:nth-child(${index + 1})`;
    
  const card = document.querySelector(selector);
  if (card) {
    card.classList.add('active-character');
  }
}

function enemyBasicAttack() {
  const aliveHeroes = selectedTeam.filter(hero => hero.hp > 0);
  if (aliveHeroes.length === 0) {
    handleDefeat();
    return;
  }

  const targetIndex = Math.floor(Math.random() * aliveHeroes.length);
  const targetHero = aliveHeroes[targetIndex];

  // Do basic attack
  targetHero.hp -= 30; // Or whatever default enemy damage is
  updateHealthBars();
  
  // Floating "Enemy attacks!" animation (optional)
  showBattleAnnouncement("💥 Enemy attacks!");

  endTurn(); // Finally, give turn back to player
}

function showBattleAnnouncement(message, isTargeting = false) {
  const indicator = document.getElementById('turn-indicator');
  indicator.textContent = message;

  if (!isTargeting) {
    clearTimeout(indicator.timeoutId); // Clear any previous timer first
    indicator.timeoutId = setTimeout(() => {
      updateTurn();
    }, 2000);
  }
}


function showCustomPopup(message) {
  const popup = document.getElementById('custom-popup');
  document.getElementById('popup-message').innerText = message;
  popup.style.display = 'block';
}

function closeCustomPopup() {
  document.getElementById('custom-popup').style.display = 'none';
}

function playElephantStampede() {
  const elephant = document.createElement('div');
  elephant.textContent = "🐘";
  elephant.classList.add('elephant');
  document.body.appendChild(elephant);
  
  setTimeout(() => {
    elephant.remove();
  }, 2000);
}

function playShieldWave() {
  const shield = document.createElement('div');
  shield.classList.add('shield');
  document.body.appendChild(shield);
  
  setTimeout(() => {
    shield.remove();
  }, 2000);
}

function playMysticGlow() {
  const glow = document.createElement('div');
  glow.classList.add('glow');
  document.body.appendChild(glow);
  
  setTimeout(() => {
    glow.remove();
  }, 2000);
}

function useEnemySpecial(boss) {
  const announcement = document.getElementById('turn-indicator');

  if (boss.name === "King George III") {
    // TAX THEM ALL: damage all players
    announcement.textContent = "👑 King George III uses TAX THEM ALL!";
    selectedTeam.forEach(hero => {
      hero.hp -= 200;
    });
  } else if (boss.name === "King Louis XVI") {
    // Heal himself
    announcement.textContent = "👑 King Louis XVI uses Royal Decree!";
    boss.hp = Math.min(boss.maxHp, boss.hp + 100);
  }

  updateHealthBars();
}


function generateEnemiesForLevel(level, wave) {
  if (level === 1 && wave === 1) {
    return [
      { name: "British Guard", hp: 100, maxHp: 100, attack: 30, attackLines: ['Charge!'], image: "images/bosses/britishsoldier.png" },
      { name: "British Guard", hp: 100, maxHp: 100, attack: 30, attackLines: ['Charge!'], image: "images/bosses/britishsoldier.png" },
      { name: "British Guard", hp: 100, maxHp: 100, attack: 30, attackLines: ['Charge!'], image: "images/bosses/britishsoldier.png" }
    ];
  }
  if (level === 1 && wave === 2) {
    // 🛠️ Use the full King George III template
    return [{ ...bossTemplates["King George III"] }];
  }
  return [];
}


function toggleSound() {
  soundsEnabled = !soundsEnabled;
}

function playVictorySound() {
  if (soundsEnabled) {
    const victorySound = document.getElementById('victory-sound');
    victorySound.currentTime = 0;
    victorySound.play();
  }
}

    function startGame() {
      updateUI();
      interval = setInterval(() => {
        timer--;
        timeLeft.textContent = timer;
        if (timer <= 0) {
          endGame("Out of time! King George wins. 👑");
        }
      }, 1000);
    }

    function updateUI() {
      if (currentIndex >= questions.length) {
        currentIndex = 0;
      }

      const q = questions[currentIndex];
      questionText.textContent = q.prompt;

      // Shuffle answers
      const allOptions = [...q.wrong, q.correct].sort(() => 0.5 - Math.random());

      optionsDiv.innerHTML = "";
      allOptions.forEach(opt => {
        const btn = document.createElement('button');
        btn.classList.add('option');
        btn.textContent = opt;
        btn.onclick = () => {
          if (opt === q.correct) {
            score += 15;
          } else {
            score -= 10;
          }

          score = Math.min(100, Math.max(0, score));
          patriotScore.textContent = score;
          patriotFill.style.width = `${score}%`;

          if (score >= 100) {
            endGame("Victory! The Colonies cheer your wit! 🦅");
          } else if (score <= 0) {
            endGame("Defeat! You lost the crowd. 🍵");
          } else {
            currentIndex++;
            updateUI();
          }
        };
        optionsDiv.appendChild(btn);
      });
    }
    function playerWinsLevel1() {
  console.log("Player wins American Revolution!");

  // Play victory sound
  const victorySound = document.getElementById('victory-sound');
  victorySound.currentTime = 0;
  victorySound.play();

  // Show victory overlay
  const overlay = document.getElementById('victory-overlay');
  overlay.style.display = 'block';

  // Show the "Next!" button
  const nextButton = document.getElementById('next-button');
  nextButton.style.display = 'block';

// ✨ Trigger shine swipe when button appears
const buttonShine = document.getElementById('button-shine');
buttonShine.style.animation = 'shineMove 2s ease-out forwards';

  nextButton.style.animation = 'pulseNext 2s infinite';

  // 🚀 Instead of redirecting, go to hero selection
  nextButton.onclick = () => {
    overlay.style.display = 'none';
    nextButton.style.display = 'none';
    document.getElementById('result').classList.add('hidden');
    document.getElementById('hero-select-screen').classList.remove('hidden');
    renderHeroSelection();
  };
}

function endGame(message) {
  clearInterval(interval);
  questionBox.classList.add('hidden');
  resultBox.textContent = message;
  resultBox.classList.remove('hidden');

  if (message.includes("Victory")) {
    // If player won, trigger the full victory celebration!
    playerWinsLevel1();
  }
}
function renderHeroSelection() {
    const confirmButton = document.getElementById('confirm-heroes');
confirmButton.onclick = null;

  const heroList = document.getElementById('hero-list');
  heroList.innerHTML = '';

  const unlockedLevel = getHighestLevelWon(); // We'll track this from your progress
  selectedTeam = [];

  allHeroes.forEach(hero => {
  const card = document.createElement('div');
  card.className = 'hero-card';
  if (!unlockedHeroes.includes(hero.id)) {
    card.classList.add('locked'); // Add gray + non-clickable style
  }
  card.innerHTML = `
    <img src="${hero.image}" alt="${hero.name}">
    <h3>${hero.name}</h3>
  `;
  
  if (unlockedHeroes.includes(hero.id)) {
  card.addEventListener('click', () => {
    if (selectedTeam.some(h => h.name === hero.name)) {
      selectedTeam = selectedTeam.filter(h => h.name !== hero.name);
      card.classList.remove('selected');
    } else if (selectedTeam.length < 3) {
      selectedTeam.push({ ...hero });
      card.classList.add('selected');
    }
    updateConfirmButton();
  });
}


  document.getElementById('hero-list').appendChild(card);
});
  confirmButton.onclick = () => {
  if (selectedTeam.length === 3) {
    startBattle(selectedTeam);
  }
};
}

function selectHero(hero, card) {
  if (selectedTeam.some(h => h.name === hero.name)) {
    selectedTeam = selectedTeam.filter(h => h.name !== hero.name);
    card.classList.remove('selected');
  } else if (selectedTeam.length < 3) {
    selectedTeam.push({ ...hero }); // 🛠 FULL clone with stats
    card.classList.add('selected');
  }
  updateConfirmButton();
}

function updateConfirmButton() {
  const confirmButton = document.getElementById('confirm-heroes');
  if (selectedTeam.length === 3) {
    confirmButton.disabled = false;
    confirmButton.classList.remove('disabled');
  } else {
    confirmButton.disabled = true;
    confirmButton.classList.add('disabled');
  }
}

function getHighestLevelWon() {
  const highest = parseInt(localStorage.getItem('highestLevelWon') || "1");
  return highest;
}
function showBossCutscene(bossName, callback) {
  const cutscene = document.getElementById('boss-cutscene');
  document.getElementById('boss-name').textContent = bossName;

  cutscene.style.opacity = '1';
  cutscene.style.pointerEvents = 'auto';

  setTimeout(() => {
    cutscene.style.opacity = '0';
    cutscene.style.pointerEvents = 'none';
    callback();
  }, 2000); // Show for 2 seconds, then hide and continue
}
const cutsceneTexts = [
  "1765: Britain demands money from the colonies.",
  "The Colonists say: How about... no?",
  "Britain: *angry British noises*",
  "Thus begins the American Revolution!"
];

const cutsceneImages = [
  "images/cutscene/redcoats.png",
  "images/cutscene/tea_party.png",
  "images/cutscene/angry_king.png",
  "images/cutscene/revolution_flags.png"
];

let currentCutsceneIndex = 0;
const preloadedCutsceneImages = [];

function preloadCutsceneImages(callback) {
  let loaded = 0;
  cutsceneImages.forEach((src, index) => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      preloadedCutsceneImages[index] = img;
      loaded++;
      if (loaded === cutsceneImages.length) {
        callback();
      }
    };
  });
}

function startCutsceneProperly() {
  const introCutscene = document.getElementById('intro-cutscene');
  const cutsceneText = document.getElementById('cutscene-text');
  const cutsceneNextButton = document.getElementById('cutscene-next');

  function showSlide(index) {
    if (index >= preloadedCutsceneImages.length) {
  cutsceneText.style.opacity = 0;
  setTimeout(() => {
    cutsceneNextButton.style.display = 'block';
    const buttonShine = document.getElementById('button-shine');
buttonShine.style.animation = 'shineMove 2s ease-out forwards';
  }, 5);
  return;
}

    introCutscene.style.backgroundImage = `url(${preloadedCutsceneImages[index].src})`;
    cutsceneText.innerText = cutsceneTexts[index];

    introCutscene.style.opacity = '0';
    cutsceneText.style.opacity = '0';
    setTimeout(() => {
      introCutscene.style.transition = 'opacity 1.5s ease-in-out';
      introCutscene.style.opacity = '1';
      cutsceneText.style.transition = 'opacity 1.5s ease-in-out';
      cutsceneText.style.opacity = '1';
    }, 100);

    setTimeout(() => {
      currentCutsceneIndex++;
      showSlide(currentCutsceneIndex);
    }, 2500);
  }

  showSlide(0);

  // Attach "Start Game" button click AFTER the elements exist
  cutsceneNextButton.addEventListener('click', () => {
    introCutscene.style.display = 'none';
    document.getElementById('question-box').style.display = 'block';
document.querySelector('.stats').style.display = 'block';

    startGame();
  });
}

window.addEventListener('load', () => {
  // Hide normal game UI initially
  document.getElementById('question-box').style.display = 'none';
  document.querySelector('.stats').style.display = 'none';

  preloadCutsceneImages(() => {
    setTimeout(startCutsceneProperly, 300);
  });
});

  </script>
  <audio id="boss-arrival-sound" src="sounds/boss-arrival.mp3" preload="auto"></audio>
  <div id="boss-cutscene" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:black; color:white; font-size:2em; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:999999;">
    <div style="font-size:3em;">👑 A New Challenger Appears!</div>
    <div id="boss-name" style="margin-top:20px;">King George III</div>
  </div>
</body>
</html>
